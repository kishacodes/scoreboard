---
// src/components/AdminScoreboardDisplay.astro
const { games } = Astro.props;

const formatDate = (dateString: string) => {
  const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
  return new Date(dateString).toLocaleDateString('en-US', options);
}

const toTitleCase = (str: string) => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
---

<div class="scoreboard-grid" id="admin-scoreboard">
  {games.map(game => (
    <div class="game-card" data-game-id={game.id}>
      <div class="game-header">
        <span class="game-date">{formatDate(game.gameDate)}</span>
        <span class="game-level">{toTitleCase(game.teams)}</span>
      </div>
      <div class="game-body">
        <div class="team">
          <span class="team-name">{game.ehs}</span>
          <input type="number" class="team-score-input" value={game.ehsScore} />
        </div>
        <div class="team">
          <span class="team-name">{game.opp}</span>
          <input type="number" class="team-score-input" value={game.oppScore} />
        </div>
        <div class="game-over-container">
          <label class="game-over-label">
            <input type="checkbox" class="game-over-checkbox" value="1" checked={game.final === 1} />
            Game Over?
          </label>
          {game.final === 1 && <span class="game-final">FINAL</span>}
        </div>
      </div>
      <div class="game-update-section">
        <div class="update-input-group">
          <div class="game-meta-inputs">
            <select class="quarter-select" aria-label="Quarter">
              <option value="">-- Quarter --</option>
              <option value="1st quarter">1st Quarter</option>
              <option value="2nd quarter">2nd Quarter</option>
              <option value="3rd quarter">3rd Quarter</option>
              <option value="4th quarter">4th Quarter</option>
            </select>
            <input 
              type="text" 
              class="time-input" 
              placeholder="Time (e.g. 4:30)" 
              aria-label="Time in quarter"
            />
          </div>
          <input 
            type="text" 
            class="update-text-input" 
            placeholder="Add update note (optional)" 
            data-game-id={game.id}
          />
          <button class="update-button">Update Score</button>
        </div>
        <div class="update-history" id={`update-history-${game.id}`}></div>
      </div>
    </div>
  ))}
</div>

<style>
  .team-score-input {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--navy-blue);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 0.5rem;
    width: 70px;
    text-align: center;
  }

  .update-input-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  
  .game-meta-inputs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  
  .quarter-select {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }
  
  .time-input {
    width: 120px;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .update-text-input {
    flex: 1;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .update-button {
    padding: 0 1.5rem;
    font-size: 0.9rem;
    font-weight: bold;
    color: #ffffff;
    background-color: var(--navy-blue);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    white-space: nowrap;
  }

  .update-button:hover {
    background-color: #003366;
  }

  .update-button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }

  .update-history {
    font-size: 0.85rem;
    color: #666;
    max-height: 200px;
    overflow-y: auto;
    padding: 0.5rem;
    background: #f8f9fa;
    border-radius: 4px;
    border: 1px solid var(--border-color);
  }

  .update-item {
    padding: 0.5rem 0;
    border-bottom: 1px solid #eee;
  }

  .update-item:last-child {
    border-bottom: none;
  }

  .update-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: #888;
    margin-bottom: 0.25rem;
  }

  .update-user {
    font-weight: 600;
    color: var(--navy-blue);
  }

  .update-time {
    font-style: italic;
  }
  
  .game-over-container {
    margin-top: 15px;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }
  
  .game-final {
    font-weight: bold;
    color: #d9534f;
    text-transform: uppercase;
    letter-spacing: 1px;
    padding: 0.25rem 0.5rem;
    border: 1px solid #d9534f;
    border-radius: 3px;
  }
  
  .game-over-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    color: #d9534f;
    cursor: pointer;
  }
  
  .game-over-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
  }
</style>

<script>
  // Define types for API responses
  interface GameUpdate {
    id: number;
    game_id: number;
    user_email: string;
    update_text: string;
    created_at: string;
  }

  interface GameData {
    id: number;
    gameDate: string;
    teams: string;
    ehs: string;
    ehsFinal: string | number;
    opp: string;
    oppFinal: string | number;
    comments?: string;
  }

  interface ApiResponse<T = any> {
    success: boolean;
    message?: string;
    error?: string;
    results?: T;
    updates?: GameUpdate[];
  }

  // Parse DB datetime strings like "YYYY-MM-DD HH:MM" or "YYYY-MM-DD HH:MM:SS" as UTC
  function parseDbDate(dateStr: string): Date {
    if (!dateStr) return new Date(NaN);
    const simple = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}(?::\d{2})?$/;
    if (simple.test(dateStr)) {
      const normalized = dateStr.replace(' ', 'T');
      const iso = dateStr.length === 16 ? `${normalized}:00Z` : `${normalized}Z`;
      return new Date(iso);
    }
    return new Date(dateStr);
  }

  // Format a DB timestamp string in Central Time (America/Chicago)
  function formatCentralTime(dateStr: string): string {
    const d = parseDbDate(dateStr);
    if (isNaN(d.getTime())) return dateStr || '';
    return d.toLocaleString('en-US', { timeZone: 'America/Chicago' });
  }

  // Function to render updates in the UI
  function renderUpdates(card: HTMLElement, updates: any[]) {
    const gameId = card.dataset.gameId;
    if (!gameId) return;
    
    const historyContainer = card.querySelector('.update-history') as HTMLElement;
    if (!historyContainer) return;
    
    if (!updates || updates.length === 0) {
      historyContainer.style.display = 'none';
      return;
    }
    
    historyContainer.style.display = 'block';
    historyContainer.innerHTML = updates.map(update => `
      <div class="update-item">
        <div class="update-meta">
          <span class="update-user">${(update.user_email || '').split('@')[0]}</span>
        </div>
        <div class="update-row">
          <span class="update-text">${update.update_text}</span>
          <span class="update-timestamp">${formatCentralTime(update.created_at)}</span>
        </div>
      </div>
    `).join('');
  }

  // Function to load update history for a game
  async function loadUpdateHistory(gameId: string) {
    try {
      const response = await fetch(`/api/games/${gameId}/updates`);
      if (!response.ok) throw new Error('Failed to load updates');
      
      const updates = await response.json() as GameUpdate[];
      const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`) as HTMLElement;
      
      if (card) {
        renderUpdates(card, updates);
      }
      
    } catch (error) {
      // Silently ignore update history load errors in production
    }
  }

  // Handle score updates
  document.addEventListener('click', async (event) => {
    const target = event.target as HTMLElement;
    if (!target.classList.contains('update-button')) {
      return;
    }

    const card = target.closest('.game-card') as HTMLElement;
    const gameId = card.dataset.gameId;
    const scoreInputs = card.querySelectorAll('.team-score-input') as NodeListOf<HTMLInputElement>;
    const updateInput = card.querySelector('.update-text-input') as HTMLInputElement;
    const qtrSelectElement = card.querySelector('.quarter-select');
    const qtrSelect = qtrSelectElement instanceof HTMLSelectElement ? qtrSelectElement : null;
    const timeInputElement = card.querySelector('.time-input');
    const timeInput = timeInputElement instanceof HTMLInputElement ? timeInputElement : null;
    const gameOverCheckbox = card.querySelector('.game-over-checkbox') as HTMLInputElement;
    
    const updateText = updateInput?.value.trim() || '';
    const qtr = qtrSelect?.value || '';
    const timeInqtr = timeInput?.value.trim() || '';
    const isFinal = gameOverCheckbox?.checked || false;

    const ehsScore = scoreInputs[0].value;
    const oppScore = scoreInputs[1].value;

    const buttonText = target.textContent;
    target.textContent = 'Updating...';
    target.setAttribute('disabled', 'true');

    // Function to handle authentication errors
    const handleAuthError = (message: string) => {
      // Clear any invalid tokens
      document.cookie = 'auth=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
      localStorage.removeItem('authToken');
      // Redirect to login with a return URL
      window.location.href = `/login?returnTo=${encodeURIComponent(window.location.pathname)}`;
    };

    // Get the auth token from cookies or localStorage
    const getAuthToken = (): string | null => {
      // Try cookies first
      const cookies = document.cookie.split('; ');
      const authCookie = cookies.find(cookie => cookie.startsWith('auth='));
      if (authCookie) {
        const token = authCookie.split('=')[1];
        return decodeURIComponent(token);
      }
      // Fallback to localStorage
      const localToken = localStorage.getItem('authToken');
      if (localToken) {
        return localToken;
      }
      return null;
    };

    // Proceeding with update

    const token = getAuthToken();
    if (!token) {
      handleAuthError('No authentication token found');
      return;
    }

    try {
      // Create request body with or without final field based on checkbox
      const requestBody: any = { 
        ehsScore: parseInt(ehsScore, 10),
        oppScore: parseInt(oppScore, 10),
        updateText: updateText,
        qtr: qtr,
        timeInqtr: timeInqtr
      };
      
      // Add final status and final scores if game over is checked
      if (isFinal) {
        requestBody.final = 1;
        requestBody.ehsFinal = parseInt(ehsScore, 10);
        requestBody.oppFinal = parseInt(oppScore, 10);
      }
      
      const response = await fetch(`/api/games/${gameId}`, {
        method: 'PATCH',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token.trim()}` // Ensure token has no whitespace
        },
        body: JSON.stringify(requestBody)
      });
      
      

      let result;
      try {
        result = await response.json() as ApiResponse<{ updates: GameUpdate[] }>;
      } catch (_) {
        throw new Error('Invalid JSON response from server');
      }
      
      if (!response.ok) {
        if (response.status === 401) {
          target.textContent = 'Auth Error';
          target.style.backgroundColor = '#d9534f';
          setTimeout(() => {
            handleAuthError('Session expired');
          }, 500);
          return;
        }
        throw new Error((result as any).error || 'Failed to update score');
      }

      // Clear the update input
      if (updateInput) {
        updateInput.value = '';
      }

      // Update the UI with the latest data
      const scoreInputs = card.querySelectorAll('.team-score-input') as NodeListOf<HTMLInputElement>;
      if (scoreInputs[0] && scoreInputs[1]) {
        scoreInputs[0].value = String(ehsScore);
        scoreInputs[1].value = String(oppScore);
      }

      // Reload the update history
      if (result.updates && result.updates.length > 0) {
        renderUpdates(card, result.updates);
      } else {
        await loadUpdateHistory(gameId);
      }

      target.textContent = 'Updated!';
      setTimeout(() => {
        target.textContent = buttonText;
        target.removeAttribute('disabled');
      }, 2000);

    } catch (error) {
      if (error instanceof Error && error.message.includes('token')) {
        handleAuthError('Invalid session');
        return;
      }
      
      target.textContent = 'Error!';
      target.style.backgroundColor = '#d9534f';
      setTimeout(() => {
        target.textContent = buttonText;
        target.removeAttribute('disabled');
        target.style.backgroundColor = '';
      }, 3000);
    }
  });

  // Load update history for all games on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Only run on admin page
    const isAdminPage = document.querySelector('[data-page="admin"]') !== null;
    if (!isAdminPage) {
      return;
    }
    
    document.querySelectorAll('.game-card').forEach(card => {
      const gameId = (card as HTMLElement).dataset.gameId;
      if (gameId) {
        loadUpdateHistory(gameId);
      }
    });
  });
</script>
