---
// src/components/AdminScoreboardDisplay.astro
const { games } = Astro.props;

const formatDate = (dateString: string) => {
  const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
  return new Date(dateString).toLocaleDateString('en-US', options);
}

const toTitleCase = (str: string) => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
---

<div class="scoreboard-grid" id="admin-scoreboard">
  {games.map(game => (
    <div class="game-card" data-game-id={game.id}>
      <div class="game-header">
        <span class="game-date">{formatDate(game.gameDate)}</span>
        <span class="game-level">{toTitleCase(game.teams)}</span>
      </div>
      <div class="game-body">
        <div class="team">
          <span class="team-name">{game.ehs}</span>
          <input type="number" class="team-score-input" value={game.ehsScore} />
        </div>
        <div class="team">
          <span class="team-name">{game.opp}</span>
          <input type="number" class="team-score-input" value={game.oppScore} />
        </div>
        <div class="game-over-container">
          <label class="game-over-label">
            <input type="checkbox" class="game-over-checkbox" />
            Game Over?
          </label>
        </div>
      </div>
      <div class="game-update-section">
        <div class="update-input-group">
          <div class="game-meta-inputs">
            <select class="quarter-select" aria-label="Quarter">
              <option value="">-- Quarter --</option>
              <option value="1st quarter">1st Quarter</option>
              <option value="2nd quarter">2nd Quarter</option>
              <option value="3rd quarter">3rd Quarter</option>
              <option value="4th quarter">4th Quarter</option>
            </select>
            <input 
              type="text" 
              class="time-input" 
              placeholder="Time (e.g. 4:30)" 
              aria-label="Time in quarter"
            />
          </div>
          <input 
            type="text" 
            class="update-text-input" 
            placeholder="Add update note (optional)" 
            data-game-id={game.id}
          />
          <button class="update-button">Update Score</button>
        </div>
        <div class="update-history" id={`update-history-${game.id}`}></div>
      </div>
    </div>
  ))}
</div>

<style>
  .team-score-input {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--navy-blue);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 0.5rem;
    width: 70px;
    text-align: center;
  }

  .update-input-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  
  .game-meta-inputs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }
  
  .quarter-select {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }
  
  .time-input {
    width: 120px;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .update-text-input {
    flex: 1;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 0.9rem;
  }

  .update-button {
    padding: 0 1.5rem;
    font-size: 0.9rem;
    font-weight: bold;
    color: #ffffff;
    background-color: var(--navy-blue);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    white-space: nowrap;
  }

  .update-button:hover {
    background-color: #003366;
  }

  .update-button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }

  .update-history {
    font-size: 0.85rem;
    color: #666;
    max-height: 200px;
    overflow-y: auto;
    padding: 0.5rem;
    background: #f8f9fa;
    border-radius: 4px;
    border: 1px solid var(--border-color);
  }

  .update-item {
    padding: 0.5rem 0;
    border-bottom: 1px solid #eee;
  }

  .update-item:last-child {
    border-bottom: none;
  }

  .update-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: #888;
    margin-bottom: 0.25rem;
  }

  .update-user {
    font-weight: 600;
    color: var(--navy-blue);
  }

  .update-time {
    font-style: italic;
  }
  
  .game-over-container {
    display: flex;
    justify-content: center;
    margin-top: 0.75rem;
  }
  
  .game-over-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
    color: #d9534f;
    cursor: pointer;
  }
  
  .game-over-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
  }
</style>

<script>
  // Define types for API responses
  interface GameUpdate {
    id: number;
    game_id: number;
    user_email: string;
    update_text: string;
    created_at: string;
  }

  interface GameData {
    id: number;
    gameDate: string;
    teams: string;
    ehs: string;
    ehsFinal: string | number;
    opp: string;
    oppFinal: string | number;
    comments?: string;
  }

  interface ApiResponse<T = any> {
    success: boolean;
    message?: string;
    error?: string;
    results?: T;
    updates?: GameUpdate[];
  }

  // Function to render updates in the UI
  function renderUpdates(card: HTMLElement, updates: any[]) {
    const gameId = card.dataset.gameId;
    if (!gameId) return;
    
    const historyContainer = card.querySelector('.update-history') as HTMLElement;
    if (!historyContainer) return;
    
    if (!updates || updates.length === 0) {
      historyContainer.style.display = 'none';
      return;
    }
    
    historyContainer.style.display = 'block';
    historyContainer.innerHTML = updates.map(update => `
      <div class="update-item">
        <div class="update-meta">
          <span class="update-user">${(update.user_email || '').split('@')[0]}</span>
          <span class="update-time">${new Date(update.created_at).toLocaleString()}</span>
        </div>
        <div class="update-text">${update.update_text}</div>
      </div>
    `).join('');
  }

  // Function to load update history for a game
  async function loadUpdateHistory(gameId: string) {
    try {
      const response = await fetch(`/api/games/${gameId}/updates`);
      if (!response.ok) throw new Error('Failed to load updates');
      
      const result = await response.json() as ApiResponse<GameUpdate[]>;
      const updates = result.results || [];
      const card = document.querySelector(`.game-card[data-game-id="${gameId}"]`) as HTMLElement;
      
      if (card) {
        renderUpdates(card, updates);
      }
      
    } catch (error) {
      console.error('Error loading update history:', error);
    }
  }

  // Handle score updates
  document.addEventListener('click', async (event) => {
    console.log('üñ±Ô∏è Click event detected on:', event.target);
    const target = event.target as HTMLElement;
    if (!target.classList.contains('update-button')) {
      console.log('‚ùå Not an update button, ignoring click');
      return;
    }
    console.log('‚úÖ Update button click confirmed');

    const card = target.closest('.game-card') as HTMLElement;
    const gameId = card.dataset.gameId;
    const scoreInputs = card.querySelectorAll('.team-score-input') as NodeListOf<HTMLInputElement>;
    const updateInput = card.querySelector('.update-text-input') as HTMLInputElement;
    const quarterSelectElement = card.querySelector('.quarter-select');
    const quarterSelect = quarterSelectElement instanceof HTMLSelectElement ? quarterSelectElement : null;
    const timeInputElement = card.querySelector('.time-input');
    const timeInput = timeInputElement instanceof HTMLInputElement ? timeInputElement : null;
    const gameOverCheckbox = card.querySelector('.game-over-checkbox') as HTMLInputElement;
    
    const updateText = updateInput?.value.trim() || '';
    const quarter = quarterSelect?.value || '';
    const timeInqtr = timeInput?.value.trim() || '';
    const isFinal = gameOverCheckbox?.checked || false;

    const ehsScore = scoreInputs[0].value;
    const oppScore = scoreInputs[1].value;

    const buttonText = target.textContent;
    target.textContent = 'Updating...';
    target.setAttribute('disabled', 'true');

    // Function to handle authentication errors
    const handleAuthError = (message: string) => {
      console.error('Authentication error:', message);
      // Clear any invalid tokens
      document.cookie = 'auth=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
      localStorage.removeItem('authToken');
      // Redirect to login with a return URL
      window.location.href = `/login?returnTo=${encodeURIComponent(window.location.pathname)}`;
    };

    // Get the auth token from cookies or localStorage
    const getAuthToken = (): string | null => {
      // Try cookies first
      const cookies = document.cookie.split('; ');
      console.log('üç™ All cookies:', cookies);
      
      const authCookie = cookies.find(cookie => cookie.startsWith('auth='));
      console.log('üîç Auth cookie found:', authCookie ? 'Yes' : 'No');
      
      if (authCookie) {
        const token = authCookie.split('=')[1];
        console.log('üîë Token from cookies (first 20 chars):', token.substring(0, 20) + '...');
        return decodeURIComponent(token); // Make sure to decode URI component
      }
      
      // Fallback to localStorage
      const localToken = localStorage.getItem('authToken');
      console.log('üîç localStorage token found:', localToken ? 'Yes' : 'No');
      
      if (localToken) {
        console.log('üîë Token from localStorage (first 20 chars):', localToken.substring(0, 20) + '...');
        return localToken;
      }
      
      return null;
    };

    console.log('üöÄ Step 1 - Update Score button clicked for game:', gameId);
    console.log('üìä Step 3 - Score values extracted - EHS:', ehsFinal, 'OPP:', oppFinal);
    console.log('üìù Step 3 - Update text:', updateText || '(none)');

    const token = getAuthToken();
    if (!token) {
      console.error('‚ùå Step 3 - Authentication failed: No token found');
      handleAuthError('No authentication token found');
      return;
    }
    
    console.log('‚úÖ Step 3 - Authentication token validated successfully');

    try {
      // Log complete request details for debugging
      console.log('üîç PATCH Request details:', {
        url: `/api/games/${gameId}`,
        token: token ? `${token.substring(0, 10)}...` : 'none',
        ehsScore: parseInt(ehsScore, 10),
        oppScore: parseInt(oppScore, 10),
        updateText: updateText,
        isFinal: isFinal
      });
      
      // Create request body with or without final field based on checkbox
      const requestBody: any = { 
        ehsScore: parseInt(ehsScore, 10),
        oppScore: parseInt(oppScore, 10),
        updateText: updateText,
        qtr: quarter,
        timeInqtr: timeInqtr
      };
      
      // Add final status and final scores if game over is checked
      if (isFinal) {
        requestBody.final = 1;
        requestBody.ehsFinal = parseInt(ehsScore, 10);
        requestBody.oppFinal = parseInt(oppScore, 10);
      }
      
      const response = await fetch(`/api/games/${gameId}`, {
        method: 'PATCH',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token.trim()}` // Ensure token has no whitespace
        },
        body: JSON.stringify(requestBody)
      });
      
      console.log('üîÑ PATCH Response status:', response.status);

      let result;
      try {
        result = await response.json() as ApiResponse<{ updates: GameUpdate[] }>;
      } catch (jsonError) {
        console.error('‚ùå JSON Parse Error:', jsonError);
        // Clone the response to read text without consuming the stream
        const responseClone = response.clone();
        try {
          const responseText = await responseClone.text();
          console.error('‚ùå Raw response:', responseText);
        } catch (textError) {
          console.error('‚ùå Could not read response text:', textError);
        }
        throw new Error('Invalid JSON response from server');
      }
      
      if (!response.ok) {
        console.error('‚ùå PATCH Request Failed - Status:', response.status);
        console.error('‚ùå PATCH Response:', result);
        
        if (response.status === 401) {
          console.error('‚ùå 401 Unauthorized - Token may be invalid or expired');
          // Don't immediately redirect, let user see the error
          target.textContent = 'Auth Error - Check Console';
          target.style.backgroundColor = '#d9534f';
          setTimeout(() => {
            handleAuthError('Session expired');
          }, 5000); // Give 5 seconds to read console
          return;
        }
        throw new Error(result.error || 'Failed to update score');
      }

      // Clear the update input
      if (updateInput) {
        updateInput.value = '';
      }

      // Update the UI with the latest data
      const scoreInputs = card.querySelectorAll('.team-score-input') as NodeListOf<HTMLInputElement>;
      if (scoreInputs[0] && scoreInputs[1]) {
        scoreInputs[0].value = String(ehsScore);
        scoreInputs[1].value = String(oppScore);
      }

      // Reload the update history
      if (result.updates && result.updates.length > 0) {
        renderUpdates(card, result.updates);
      } else {
        await loadUpdateHistory(gameId);
      }

      target.textContent = 'Updated!';
      setTimeout(() => {
        target.textContent = buttonText;
        target.removeAttribute('disabled');
      }, 2000);

    } catch (error) {
      console.error('Update Error:', error);
      if (error instanceof Error && error.message.includes('token')) {
        handleAuthError('Invalid session');
        return;
      }
      
      target.textContent = 'Error!';
      target.style.backgroundColor = '#d9534f';
      setTimeout(() => {
        target.textContent = buttonText;
        target.removeAttribute('disabled');
        target.style.backgroundColor = '';
      }, 3000);
    }
  });

  // Load update history for all games on page load
  document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ AdminScoreboardDisplay script loaded');
    console.log('üìÑ Current page body dataset:', document.body.dataset);
    console.log('üéØ Game cards found:', document.querySelectorAll('.game-card').length);
    console.log('üîò Update buttons found:', document.querySelectorAll('.update-button').length);
    
    // Check if we're on the admin page
    const isAdminPage = document.querySelector('[data-page="admin"]') !== null;
    if (!isAdminPage) {
      console.log('‚ùå Not on admin page, skipping initialization');
      return;
    }
    console.log('‚úÖ Admin page confirmed');
    
    document.querySelectorAll('.game-card').forEach(card => {
      const gameId = (card as HTMLElement).dataset.gameId;
      if (gameId) {
        loadUpdateHistory(gameId);
      }
    });
  });
</script>
