---
// src/components/ScoreboardFilter.astro
---

<form id="filter-form" class="filter-container">
  <div class="filter-group">
    <label for="search-team">Team Name</label>
    <input type="text" id="search-team" name="team" placeholder="Search for a team...">
  </div>
  <div class="filter-group">
    <label for="filter-teams">Level</label>
    <select id="filter-teams" name="teams">
      <option value="">All Levels</option>
      <option value="Varsity">Varsity</option>
      <option value="Junior Varsity">Junior Varsity</option>
      <option value="Freshmen">Freshmen</option>
    </select>
  </div>
  <div class="filter-group">
    <label for="filter-gameDate">Game Date</label>
    <input type="date" id="filter-gameDate" name="gameDate">
  </div>
  <div class="filter-group">
    <button type="reset">Clear Filters</button>
  </div>
</form>

<style>
  .filter-container {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    padding: 1.5rem;
    background-color: #ffffff;
    border-radius: 8px;
    margin-top: 2rem;
    margin-bottom: 2rem;
    border: 1px solid var(--border-color);
  }

  .filter-group {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
  }

  .filter-group label {
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    font-weight: 500;
  }

  .filter-group input,
  .filter-group select {
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 1rem;
  }

  .filter-group button {
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 1rem;
    background-color: var(--light-gray);
    cursor: pointer;
    align-self: flex-end;
    height: 100%;
  }
  
  /* Game Final Status Styling */
  .game-final {
    font-weight: bold;
    color: #d9534f;
    text-transform: uppercase;
    letter-spacing: 1px;
    padding: 0.25rem 0.5rem;
    border: 1px solid #d9534f;
    border-radius: 3px;
  }
  
  /* Updates list styles to match display component and optimize for mobile */
  .updates-list {
    list-style: none;
    padding: 0;
    margin: 0.5rem 0 0 0;
    font-size: 0.85rem;
  }
  .update-item {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background-color: #f9f9f9;
    border-left: 3px solid #ddd;
  }
  .update-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 0.5rem;
  }
  .update-text {
    flex: 1 1 auto;
    min-width: 0;
    word-break: break-word;
  }
  .update-timestamp {
    flex: 0 0 auto;
    font-size: 0.5em; /* half size of the update text */
    color: #777;
    white-space: nowrap;
  }
  .update-meta {
    margin-top: 0.25rem;
    font-size: 0.8em;
    color: #555;
  }
</style>

<script>
  interface GameUpdate {
    id: number;
    game_id: number;
    user_email: string;
    update_text: string;
    created_at: string;
  }

  interface Game {
    id: number;
    gameDate: string;
    teams: string;
    ehs: string;
    ehsScore: number;
    oppScore: number;
    ehsFinal: number;
    opp: string;
    oppFinal: number;
    qtr: string | null;
    timeInqtr: string | null;
    comments: string;
    final?: number;
    updates?: GameUpdate[];
  }

  const formatDate = (dateString: string): string => {
    if (!dateString) return '';
    const options: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
    return new Date(dateString).toLocaleDateString('en-US', options);
  }

  const toTitleCase = (str: string): string => {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }

  // Helpers to lazy-load updates for dynamically rendered cards
  const escapeHtml = (str: string): string => String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\"/g, '&quot;')
    .replace(/'/g, '&#39;');

  // Parse DB datetime strings like "YYYY-MM-DD HH:MM" or "YYYY-MM-DD HH:MM:SS" as UTC
  const parseDbDate = (dateStr: string): Date => {
    if (!dateStr) return new Date(NaN);
    const simple = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}(?::\d{2})?$/;
    if (simple.test(dateStr)) {
      const normalized = dateStr.replace(' ', 'T');
      const iso = dateStr.length === 16 ? `${normalized}:00Z` : `${normalized}Z`;
      return new Date(iso);
    }
    return new Date(dateStr);
  };

  // Format a DB timestamp string in Central Time (America/Chicago)
  const formatCentralTime = (dateStr: string): string => {
    const d = parseDbDate(dateStr);
    if (isNaN(d.getTime())) return String(dateStr || '');
    // Only show hour and minute for mobile-friendly display
    return d.toLocaleTimeString('en-US', {
      timeZone: 'America/Chicago',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  const attachLazyUpdateListeners = (root: Element) => {
    root.querySelectorAll('.game-card[data-game-id]').forEach((cardEl) => {
      const card = cardEl as HTMLElement;
      const gameId = card.getAttribute('data-game-id');
      const details = card.querySelector('.updates-details') as HTMLDetailsElement | null;
      if (!details || !gameId) return;
      const list = card.querySelector('.updates-list') as HTMLElement | null;
      const summary = card.querySelector('.updates-heading') as HTMLElement | null;

      details.addEventListener('toggle', async () => {
        if (!details.open) return;
        if (details.getAttribute('data-loaded') === 'true') return;
        try {
          const res = await fetch(`/api/games/${gameId}/updates`);
          const updates: any[] = res.ok ? await res.json() : [];
          if (summary) {
            summary.textContent = updates.length > 0 ? `Recent Updates (${updates.length})` : 'Recent Updates (0)';
          }
          if (!list) return;
          const teamEls = card.querySelectorAll('.team .team-name');
          const ehsName = teamEls[0]?.textContent?.trim() || 'EHS';
          const oppName = teamEls[1]?.textContent?.trim() || 'Opponent';
          if (!updates || updates.length === 0) {
            list.innerHTML = '<li class="update-item"><div class="update-row"><span class="update-text">No updates yet</span><span class="update-timestamp"></span></div></li>';
          } else {
            list.innerHTML = updates.map((u: any) => {
              const meta = (u.qtr || u.ehs_score != null || u.opp_score != null)
                ? `<div class=\"update-meta\">${escapeHtml(u.qtr || '')}${u.qtr ? ': ' : ''}${escapeHtml(ehsName)} ${escapeHtml(String(u.ehs_score ?? ''))}, ${escapeHtml(oppName)} ${escapeHtml(String(u.opp_score ?? ''))}</div>`
                : '';
              return `<li class=\"update-item\">\n                <div class=\"update-row\">\n                  <span class=\"update-text\" title=\"${escapeHtml(u.update_text)}\">${escapeHtml(u.update_text)}</span>\n                  <span class=\"update-timestamp\">${escapeHtml(formatCentralTime(u.created_at))}</span>\n                </div>\n                ${meta}\n              </li>`;
            }).join('');
          }
          details.setAttribute('data-loaded', 'true');
        } catch (_) {
          if (summary) summary.textContent = 'Recent Updates (0)';
          if (list) {
            list.innerHTML = '<li class="update-item"><div class="update-row"><span class="update-text">No updates yet</span><span class="update-timestamp"></span></div></li>';
          }
          details.setAttribute('data-loaded', 'true');
        }
      });
    });
  };

  // Detect admin page: look for any element with data-page="admin"
  const isAdmin = document.querySelector('[data-page="admin"]') !== null;

  const createGameCardHTML = (game: Game): string => {
    if (isAdmin) {
      return `
        <div class="game-card" data-game-id="${game.id}">
          <div class="game-header">
            <span class="game-date">${formatDate(game.gameDate)}</span>
            <span class="game-level">${toTitleCase(game.teams)}</span>
          </div>
          <div class="game-body">
            <div class="team">
              <span class="team-name">${game.ehs}</span>
              <input type="number" class="team-score-input" value="${game.ehsScore !== undefined ? game.ehsScore : game.ehsFinal}" />
            </div>
            <div class="team">
              <span class="team-name">${game.opp}</span>
              <input type="number" class="team-score-input" value="${game.oppScore !== undefined ? game.oppScore : game.oppFinal}" />
            </div>
            <div class="game-over-container">
              <label class="game-over-label">
                <input type="checkbox" class="game-over-checkbox" value="1" ${game.final === 1 ? 'checked' : ''} />
                Game Over?
              </label>
              ${game.final === 1 ? '<span class="game-final">FINAL</span>' : ''}
            </div>
          </div>
          <div class="game-update-section">
            <div class="update-input-group">
              <div class="game-meta-inputs">
                <select class="quarter-select" aria-label="Quarter">
                  <option value="">-- Quarter --</option>
                  <option value="1st quarter">1st Quarter</option>
                  <option value="2nd quarter">2nd Quarter</option>
                  <option value="3rd quarter">3rd Quarter</option>
                  <option value="4th quarter">4th Quarter</option>
                </select>
                <input type="text" class="time-input" placeholder="Time (e.g. 4:30)" aria-label="Time in quarter" />
              </div>
              <input type="text" class="update-text-input" placeholder="Add update note (optional)" data-game-id="${game.id}" />
              <button class="update-button">Update Score</button>
            </div>
            <div class="update-history" id="update-history-${game.id}"></div>
          </div>
        </div>
      `;
    } else {
      // Prepare game status display - show FINAL for completed games
      let statusHTML = '';
      
      if (game.final === 1) {
        statusHTML = `
          <div class="game-status">
            <span class="game-final">FINAL</span>
          </div>
        `;
      } else if (game.qtr || game.timeInqtr) {
        statusHTML = `
          <div class="game-status">
            ${game.qtr ? `<span class="game-quarter">${game.qtr}</span>` : ''}
            ${game.timeInqtr ? `<span class="game-time">${game.timeInqtr}</span>` : ''}
          </div>
        `;
      }
      
      return `
        <div class="game-card" data-game-id="${game.id}">
          <div class="game-header">
            <span class="game-date">${formatDate(game.gameDate)}</span>
            <span class="game-level">${toTitleCase(game.teams)}</span>
          </div>
          <div class="game-body">
            <div class="team">
              <span class="team-name">${game.ehs}</span>
              <span class="team-score">${game.ehsScore !== undefined ? game.ehsScore : game.ehsFinal}</span>
            </div>
            <div class="team">
              <span class="team-name">${game.opp}</span>
              <span class="team-score">${game.oppScore !== undefined ? game.oppScore : game.oppFinal}</span>
            </div>
            ${statusHTML}
          </div>
          <div class="game-footer">
            ${game.comments ? `<p class="game-comment">${game.comments}</p>` : ''}
            <div class="game-updates">
              <details class="updates-details" data-loaded="false">
                <summary class="updates-heading">Recent Updates</summary>
                <ul class="updates-list" aria-live="polite"></ul>
              </details>
            </div>
          </div>
        </div>
      `;
    }
  };


  document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('filter-form') as HTMLFormElement;
    const scoreboardContainer = document.querySelector('.scoreboard-container') as HTMLElement | null;

    if (!form || !scoreboardContainer) {
      return;
    }

    // Helpers from AdminScoreboardDisplay to handle auth
    const handleAuthError = (message) => {
      document.cookie = 'auth=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
      localStorage.removeItem('authToken');
      window.location.href = `/login?returnTo=${encodeURIComponent(window.location.pathname)}`;
    };

    const getAuthToken = () => {
      const cookies = document.cookie.split('; ');
      const authCookie = cookies.find((c) => c.startsWith('auth='));
      if (authCookie) return decodeURIComponent(authCookie.split('=')[1]);
      return localStorage.getItem('authToken');
    };

    async function fetchAndRenderGames() {
      const formData = new FormData(form);
      const params = new URLSearchParams();

      const team = formData.get('team') as string;
      const teams = formData.get('teams') as string;
      const gameDate = formData.get('gameDate') as string;

      if (team) params.append('team', team);
      if (teams) params.append('teams', teams);
      if (gameDate) params.append('gameDate', gameDate);

      const response = await fetch(`/api/games?${params.toString()}`);
      const games: Game[] = await response.json();

      if (games && games.length > 0 && scoreboardContainer) {
        const gamesHTML = games.map(createGameCardHTML).join('');
        scoreboardContainer.innerHTML = `<div class="scoreboard-grid">${gamesHTML}</div>`;
        attachLazyUpdateListeners(scoreboardContainer);
        // Attach admin update handler for filtered results
        if (isAdmin) {
          scoreboardContainer.querySelectorAll('.update-button').forEach((btn) => {
            btn.addEventListener('click', async (event) => {
              const target = event.target as HTMLElement;
              const card = target.closest('.game-card') as HTMLElement;
              if (!card) return;
              const gameId = card.dataset.gameId as string;
              const scoreInputs = card.querySelectorAll('.team-score-input') as NodeListOf<HTMLInputElement>;
              const updateInput = card.querySelector('.update-text-input') as HTMLInputElement | null;
              const qtrSelectEl = card.querySelector('.quarter-select');
              const qtrSelect = qtrSelectEl instanceof HTMLSelectElement ? qtrSelectEl : null;
              const timeInputEl = card.querySelector('.time-input');
              const timeInput = timeInputEl instanceof HTMLInputElement ? timeInputEl : null;
              const gameOverCheckbox = card.querySelector('.game-over-checkbox') as HTMLInputElement | null;

              const updateText = updateInput?.value.trim() || '';
              const qtr = qtrSelect?.value || '';
              const timeInqtr = timeInput?.value.trim() || '';
              const isFinal = !!(gameOverCheckbox?.checked);

              const ehsScore = scoreInputs[0]?.value ?? '0';
              const oppScore = scoreInputs[1]?.value ?? '0';

              const token = getAuthToken();
              if (!token) {
                handleAuthError('No authentication token found');
                return;
              }

              const buttonText = target.textContent;
              target.textContent = 'Updating...';
              target.setAttribute('disabled', 'true');

              try {
                const body: any = {
                  ehsScore: parseInt(ehsScore, 10),
                  oppScore: parseInt(oppScore, 10),
                  updateText,
                  qtr,
                  timeInqtr
                };
                if (isFinal) {
                  body.final = 1;
                  body.ehsFinal = parseInt(ehsScore, 10);
                  body.oppFinal = parseInt(oppScore, 10);
                }

                const response = await fetch(`/api/games/${gameId}`, {
                  method: 'PATCH',
                  credentials: 'include',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token.trim()}`
                  },
                  body: JSON.stringify(body)
                });

                let result: any = {};
                try { result = await response.json(); } catch {}

                if (!response.ok) {
                  if (response.status === 401) {
                    target.textContent = 'Auth Error';
                    target.style.backgroundColor = '#d9534f';
                    setTimeout(() => handleAuthError('Session expired'), 500);
                    return;
                  }
                  throw new Error(result?.error || 'Failed to update score');
                }

                if (updateInput) updateInput.value = '';
                target.textContent = 'Updated!';
                setTimeout(() => {
                  target.textContent = buttonText || 'Update Score';
                  target.removeAttribute('disabled');
                  target.style.backgroundColor = '';
                }, 2000);
              } catch (err) {
                target.textContent = 'Error!';
                target.style.backgroundColor = '#d9534f';
                setTimeout(() => {
                  target.textContent = buttonText || 'Update Score';
                  target.removeAttribute('disabled');
                  target.style.backgroundColor = '';
                }, 3000);
              }
            });
          });
        }
      } else {
        scoreboardContainer.innerHTML = `<p>No games found matching your criteria.</p>`;
      }
    }

    let debounceTimer: number;
    form.addEventListener('input', () => {
      clearTimeout(debounceTimer);
      debounceTimer = window.setTimeout(fetchAndRenderGames, 300);
    });

    form.addEventListener('reset', () => {
      setTimeout(fetchAndRenderGames, 0);
    });
  });
</script>
